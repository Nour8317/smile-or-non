# -*- coding: utf-8 -*-
"""smileornot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rvNQIVxJrYNg38-Zu9htjRgVXP2EH1oS
"""

!pip install tensorflow

import tensorflow as tf
import numpy as np
import cv2
import matplotlib.pyplot as plt
import glob
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D,MaxPooling2D,Dense,Flatten,Dropout
from tensorflow.keras.metrics import Precision, Recall, BinaryAccuracy
from tensorflow.keras.models import load_model
from tensorflow.keras.optimizers import SGD

"""fetching the dataset"""

tf.keras.utils.image_dataset_from_directory??

data = tf.keras.utils.image_dataset_from_directory(
    'data',
    labels='inferred',
    label_mode='int',
    image_size=(256, 256),
    batch_size=32,
    shuffle=True,
)

len(data)

36 * 32

data_iterator = data.as_numpy_iterator()

data_iterator

"""the dataset represented as a numpy array

"""

batch = data_iterator.next()

"""preprocessing the data by applying the normalization technique

"""

batch[1]

fig, ax = plt.subplots(ncols=4, figsize=(20,20))
for idx, img in enumerate (batch[0][:4]):
  ax[idx].imshow(img.astype(int))
  ax[idx].title.set_text(batch[1][idx])

data = data.map(lambda x,y: (x/255,y))

scaled_data = data.as_numpy_iterator().next()

scaled_data[0].min()
scaled_data[0].max()

fig, ax = plt.subplots(ncols=4, figsize=(20,20))
for idx, img in enumerate (batch[0][:4]):
  ax[idx].imshow(img.astype(int))
  ax[idx].title.set_text(batch[1][idx])

"""Spliting The Data To Train Validate Test

"""

train_size = int(len(data)*0.7)
validate_size = int(len(data)*0.2)
test_size=int(len(data)*0.1)+1

train = data.take(train_size)
val = data.skip(train_size).take(validate_size)
test = data.skip(train_size + validate_size).take(test_size)

"""Building the model"""

model = Sequential()

model.add(Conv2D(16, (3,3), 1, activation='relu', input_shape=(256,256,3)))
model.add(MaxPooling2D())
model.add(Conv2D(32, (3,3), 1, activation='relu'))
model.add(MaxPooling2D())
model.add(Conv2D(16, (3,3), 1, activation='relu'))
model.add(MaxPooling2D())
model.add(Flatten())
model.add(Dense(256, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

model.compile('adam', loss=tf.losses.BinaryCrossentropy(), metrics=['accuracy'])

model.summary()

logdir='logs'

tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=logdir)

hist = model.fit(train, epochs=20, validation_data=val, callbacks=[tensorboard_callback])

hist

fig = plt.figure()
plt.plot(hist.history['loss'], color='teal', label='loss')
plt.plot(hist.history['val_loss'], color='orange', label='val_loss')
fig.suptitle('Loss', fontsize=20)
plt.legend(loc="upper left")
plt.show()

fig = plt.figure()
plt.plot(hist.history['accuracy'], color='teal', label='accuracy')
plt.plot(hist.history['val_accuracy'], color='orange', label='val_accuracy')
fig.suptitle('Accuracy', fontsize=20)
plt.legend(loc="upper left")
plt.show()

pre = Precision()
re = Recall()
acc = BinaryAccuracy()

for batch in test.as_numpy_iterator():
    X, y = batch
    yhat = model.predict(X)
    pre.update_state(y, yhat)
    re.update_state(y, yhat)
    acc.update_state(y, yhat)

print(f"precision: {pre.result().numpy()}, recall: {re.result().numpy()}, accuracy: {acc.result().numpy()}")

img = cv2.imread("noor.jpg")
plt.imshow(img)

resize = tf.image.resize(img, (256,256))
plt.imshow(resize.numpy().astype(int))
plt.show()

yhat = model.predict(np.expand_dims(resize/255, 0))
yhat

if yhat >0.5:
  print("Smiling")
else:
  print("Not Smiling")

model2 = Sequential()
model2.add(Flatten(input_shape=(256, 256, 3)))
model2.add(Dense(16, activation='relu'))
model2.add(Dense(32, activation='relu'))
model2.add(Dense(16, activation='relu'))
model2.add(Dense(1, activation='sigmoid'))

learning_rate = 0.01
momentum = 0.9

optimizer = SGD(learning_rate=learning_rate, momentum=momentum)

model2.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

model2.summary()

hist2 = model2.fit(train, epochs=20, validation_data=val, callbacks=[tensorboard_callback])

fig = plt.figure()
plt.plot(hist2.history['loss'], color='teal', label='loss')
plt.plot(hist2.history['val_loss'], color='orange', label='val_loss')
fig.suptitle('Loss', fontsize=20)
plt.legend(loc="upper left")
plt.show()

fig = plt.figure()
plt.plot(hist2.history['accuracy'], color='teal', label='accuracy')
plt.plot(hist2.history['val_accuracy'], color='orange', label='val_accuracy')
fig.suptitle('Accuracy', fontsize=20)
plt.legend(loc="upper left")
plt.show()

pre2 = Precision()
re2 = Recall()
acc2 = BinaryAccuracy()

for batch in test.as_numpy_iterator():
    X, y = batch
    yhat2 = model2.predict(X)
    yhat2 = [1 if prediction > 0.5 else 0 for prediction in yhat2 ]
    pre2.update_state(y, yhat2)
    re2.update_state(y, yhat2)
    acc2.update_state(y, yhat2)

print(f"precision: {pre2.result().numpy()}, recall: {re2.result().numpy()}, accuracy: {acc2.result().numpy()}")

img = cv2.imread("noor.jpg")
plt.imshow(img)

resize = tf.image.resize(img, (256,256))
plt.imshow(resize.numpy().astype(int))
plt.show()

yhat2 = model2.predict(np.expand_dims(resize/255, 0))
yhat2

if yhat2 >0.5:
  print("Smiling")
else:
  print("Not Smiling")

model3 = Sequential()
model3.add(Flatten(input_shape=(256, 256, 3)))
model3.add(Dense(32, activation='relu'))
model3.add(Dense(32, activation='relu'))
model3.add(Dense(16, activation='relu'))
model3.add(Dense(32, activation='relu'))
model3.add(Dense(16, activation='relu'))
model3.add(Dense(1, activation='sigmoid'))

from tensorflow.keras.optimizers import RMSprop
from tensorflow.keras.losses import MeanSquaredError

optimizer = RMSprop(learning_rate=0.001)

loss_function = MeanSquaredError()

model3.compile(optimizer=optimizer, loss=loss_function, metrics=['accuracy'])

model3.summary()

hist3 = model3.fit(train, epochs=20, validation_data=val, callbacks=[tensorboard_callback])

fig = plt.figure()
plt.plot(hist3.history['loss'], color='teal', label='loss')
plt.plot(hist3.history['val_loss'], color='orange', label='val_loss')
fig.suptitle('Loss', fontsize=20)
plt.legend(loc="upper left")
plt.show()

fig = plt.figure()
plt.plot(hist3.history['accuracy'], color='teal', label='accuracy')
plt.plot(hist3.history['val_accuracy'], color='orange', label='val_accuracy')
fig.suptitle('Accuracy', fontsize=20)
plt.legend(loc="upper left")
plt.show()

pre3 = Precision()
re3 = Recall()
acc3 = BinaryAccuracy()

for batch in test.as_numpy_iterator():
    X, y = batch
    yhat3 = model3.predict(X)
    # yhat3 = [1 if prediction > 0.5 else 0 for prediction in yhat3 ] ask the TA
    pre3.update_state(y, yhat3)
    re3.update_state(y, yhat3)
    acc3.update_state(y, yhat3)

print(f"precision: {pre3.result().numpy()}, recall: {re3.result().numpy()}, accuracy: {acc3.result().numpy()}")

img = cv2.imread("noor.jpg")
plt.imshow(img)

resize = tf.image.resize(img, (256,256))
plt.imshow(resize.numpy().astype(int))
plt.show()

yhat3 = model3.predict(np.expand_dims(resize/255, 0))

if yhat3 >0.5:
  print("Smiling")
else:
  print("Not Smiling")

model4 = Sequential([
    Flatten(input_shape=(256, 256, 3)),
    Dense(128, activation='relu'),
    Dropout(0.4),
    Dense(128, activation='relu'),
    Dropout(0.4),
    Dense(64, activation='relu'),
    Dropout(0.4),
    Dense(1, activation='sigmoid')
])

model4.compile('adam', loss=tf.losses.BinaryCrossentropy(), metrics=['accuracy'])

model4.summary()

hist4 = model4.fit(train, epochs=20, validation_data=val, callbacks=[tensorboard_callback])

fig = plt.figure()
plt.plot(hist4.history['loss'], color='teal', label='loss')
plt.plot(hist4.history['val_loss'], color='orange', label='val_loss')
fig.suptitle('Loss', fontsize=20)
plt.legend(loc="upper left")
plt.show()

fig = plt.figure()
plt.plot(hist4.history['accuracy'], color='teal', label='accuracy')
plt.plot(hist4.history['val_accuracy'], color='orange', label='val_accuracy')
fig.suptitle('Accuracy', fontsize=20)
plt.legend(loc="upper left")
plt.show()

for batch in test.as_numpy_iterator():
    X, y = batch
    yhat3 = model4.predict(X)
    # yhat3 = [1 if prediction > 0.5 else 0 for prediction in yhat3 ] ask the TA
    pre3.update_state(y, yhat3)
    re3.update_state(y, yhat3)
    acc3.update_state(y, yhat3)

print(f"precision: {pre3.result().numpy()}, recall: {re3.result().numpy()}, accuracy: {acc3.result().numpy()}")